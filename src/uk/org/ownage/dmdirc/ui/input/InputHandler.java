/*
 * Copyright (c) 2006-2007 Chris Smith, Shane Mc Cormack, Gregory Holmes
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package uk.org.ownage.dmdirc.ui.input;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

import javax.swing.JTextField;

import uk.org.ownage.dmdirc.Config;
import uk.org.ownage.dmdirc.commandparser.CommandParser;
import uk.org.ownage.dmdirc.commandparser.CommandWindow;
import uk.org.ownage.dmdirc.ui.components.ColourPickerDialog;
import uk.org.ownage.dmdirc.ui.messages.Styliser;

/**
 * Handles events generated by a user typing into a textfield. Allows the user
 * to use shortcut keys for control characters (ctrl+b, etc), to tab complete
 * nicknames/channel names/etc, and to scroll through their previously issued
 * commands.
 * @author chris
 */
public final class InputHandler implements KeyListener, ActionListener {
    
    /**
     * Indicates that the caret should be moved to the end of a selection when
     * a control code has been inserted.
     */
    private static final int POSITION_END = 1;
    
    /**
     * Indicates that the caret should be moved to the start of a selection when
     * a control code has been inserted.
     */
    private static final int POSITION_START = 2;
    
    /**
     * The current position in the buffer (where the user has scrolled back
     * to).
     */
    private int bufferPosition;
    /**
     * The maximum size of the buffer.
     */
    private int bufferSize;
    /**
     * The maximum position we've got to in the buffer. This will be the
     * position that is inserted to next. Note that it will wrap around once
     * we hit the maximum size.
     */
    private int bufferMaximum;
    /**
     * The lowest entry we've used in the buffer.
     */
    private int bufferMinimum;
    /**
     * The buffer itself.
     */
    private String[] buffer;
    /**
     * The textfield that we're handling input for.
     */
    private final JTextField target;
    /**
     * The TabCompleter to use for tab completion.
     */
    private TabCompleter tabCompleter;
    /**
     * The CommandParser to use for our input.
     */
    private final CommandParser commandParser;
    /**
     * The frame that we belong to.
     */
    private final CommandWindow parentWindow;
    
    /** Colour picker dialog. */
    private ColourPickerDialog colourPicker;
    
    /**
     * Creates a new instance of InputHandler. Adds listeners to the target
     * that we need to operate.
     * @param thisTarget The text field this input handler is dealing with.
     * @param thisCommandParser The command parser to use for this text field.
     * @param thisParentWindow The window that owns this input handler
     */
    public InputHandler(final JTextField thisTarget,
            final CommandParser thisCommandParser,
            final CommandWindow thisParentWindow) {
        
        bufferSize = thisParentWindow.getConfigManager().getOptionInt("ui", "inputbuffersize", 50);
        
        this.commandParser = thisCommandParser;
        this.parentWindow = thisParentWindow;
        this.target = thisTarget;
        this.buffer = new String[bufferSize];
        bufferPosition = 0;
        bufferMinimum = 0;
        bufferMaximum = 0;
        
        target.addKeyListener(this);
        target.addActionListener(this);
        target.setFocusTraversalKeysEnabled(false);
    }
    
    /**
     * Sets this input handler's tab completer.
     * @param newTabCompleter The new tab completer
     */
    public void setTabCompleter(final TabCompleter newTabCompleter) {
        tabCompleter = newTabCompleter;
    }
    
    /**
     * Called when the user types a normal character.
     * @param keyEvent The event that was fired
     */
    public void keyTyped(final KeyEvent keyEvent) {
        //Ignore.
    }
    
    /**
     * Called when the user presses down any key. Handles the insertion of
     * control codes, tab completion, and scrolling the back buffer.
     * @param keyEvent The event that was fired
     */
    public void keyPressed(final KeyEvent keyEvent) {
        if (colourPicker != null) {
            colourPicker.dispose();
            colourPicker = null;
        }
        // Formatting codes
        if ((keyEvent.getModifiers() & KeyEvent.CTRL_MASK) != 0) {
            if (keyEvent.getKeyCode() == KeyEvent.VK_B) {
                addControlCode(Styliser.CODE_BOLD, POSITION_END);
            }
            if (keyEvent.getKeyCode() == KeyEvent.VK_U) {
                addControlCode(Styliser.CODE_UNDERLINE, POSITION_END);
            }
            if (keyEvent.getKeyCode() == KeyEvent.VK_O) {
                addControlCode(Styliser.CODE_STOP, POSITION_END);
            }
            if (keyEvent.getKeyCode() == KeyEvent.VK_I) {
                addControlCode(Styliser.CODE_ITALIC, POSITION_END);
            }
            if (keyEvent.getKeyCode() == KeyEvent.VK_F) {
                addControlCode(Styliser.CODE_FIXED, POSITION_END);
            }
            if (keyEvent.getKeyCode() == KeyEvent.VK_K) {
                if ((keyEvent.getModifiers() & KeyEvent.SHIFT_MASK) != 0) {
                    addControlCode(Styliser.CODE_HEXCOLOUR, POSITION_START);
                    showColourPicker(false, true);
                } else {
                    addControlCode(Styliser.CODE_COLOUR, POSITION_START);
                    showColourPicker(true, false);
                }
            }
            
            // Ctrl+Enter
            if (keyEvent.getKeyChar() == KeyEvent.VK_ENTER) {
                commandParser.parseCommandCtrl(parentWindow, target.getText());
                addToBuffer(target.getText());
            }
        }
        
        // Back buffer scrolling
        if (keyEvent.getKeyCode() == KeyEvent.VK_UP) {
            if (bufferPosition != bufferMinimum) {
                bufferPosition = normalise(bufferPosition - 1);
                retrieveBuffer();
            } else {
                // TODO: Beep, or something.
            }
        } else if (keyEvent.getKeyCode() == KeyEvent.VK_DOWN) {
            if (bufferPosition != bufferMaximum) {
                bufferPosition = normalise(bufferPosition + 1);
                retrieveBuffer();
            } else if (!target.getText().equals("")) {
                addToBuffer(target.getText());
            } else {
                // TODO: Beep, or something
            }
        }
        
        // Tab completion
        if (keyEvent.getKeyCode() == KeyEvent.VK_TAB && tabCompleter != null) {
            String text = target.getText();
            
            if ("".equals(text)) {
                return;
            }
            
            final int pos = target.getCaretPosition() - 1;
            int start = (pos < 0) ? 0 : pos;
            int end = (pos < 0) ? 0 : pos;
            
            // Traverse backwards
            while (start > 0 && text.charAt(start) != ' ') {
                start--;
            }
            if (text.charAt(start) == ' ') { start++; }
            
            // And forwards
            while (end < text.length() && text.charAt(end) != ' ') {
                end++;
            }
            
            if (start > end) {
                return;
            }
            
            final String word = text.substring(start, end);
            
            final TabCompleterResult res = tabCompleter.complete(word);
            
            if (res.getResultCount() == 0) {
                // TODO: Beep, or something
            } else if (res.getResultCount() == 1) {
                // One result, just replace it
                final String result = res.getResults().get(0);
                text = text.substring(0, start) + result + text.substring(end);
                target.setText(text);
                target.setCaretPosition(start + result.length());
            } else {
                // Multiple results
                final String sub = res.getBestSubstring();
                if (sub.equalsIgnoreCase(word)) {
                    // TODO: Beep, display possible answers, etc
                } else {
                    text = text.substring(0, start) + sub + text.substring(end);
                    target.setText(text);
                    target.setCaretPosition(start + sub.length());
                }
            }
            
        }
    }
    
    /**
     * Called when the user releases any key.
     * @param keyEvent The event that was fired
     */
    public void keyReleased(final KeyEvent keyEvent) {
        //Ignore.
    }
    
    /**
     * Called when the user presses return in the text area. The line they
     * typed is added to the buffer for future use.
     * @param actionEvent The event that was fired
     */
    public void actionPerformed(final ActionEvent actionEvent) {
        final String line = actionEvent.getActionCommand();
        
        if (line.length() > 0) {
            addToBuffer(line);
            
            commandParser.parseCommand(parentWindow, line);
        }
    }
    
    /**
     * Adds the specified control code to the textarea. If the user has a range
     * of text selected, the characters are added before and after, and the
     * caret is positioned based on the position argument.
     * @param code The control code to add
     * @param position The position of the caret after a selection is altered
     */
    private void addControlCode(final int code, final int position) {
        final String insert = "" + (char) code;
        final int selectionEnd = target.getSelectionEnd();
        final int selectionStart = target.getSelectionStart();
        if (selectionStart < selectionEnd) {
            final String source = target.getText();
            final String before = source.substring(0, selectionStart);
            final String selected = target.getSelectedText();
            final String after = source.substring(selectionEnd, source.length());
            target.setText(before + insert + selected + insert + after);
            if (position == POSITION_START) {
                target.setCaretPosition(selectionStart + 1);
            } else if (position == POSITION_END) {
                target.setCaretPosition(selectionEnd + 2);
            }
        } else {
            final int offset = target.getCaretPosition();
            final String source = target.getText();
            final String before = target.getText().substring(0, offset);
            final String after = target.getText().substring(offset, source.length());
            target.setText(before + insert + after);
            target.setCaretPosition(offset + 1);
        }
    }
    
    /**
     * Retrieves the buffered text stored at the position indicated by
     * bufferPos, and replaces the current textbox content with it.
     */
    private void retrieveBuffer() {
        target.setText(buffer[bufferPosition]);
    }
    
    /**
     * Normalises the input so that it is in the range 0 <= x < bufferSize.
     * @param input The number to normalise
     * @return The normalised number
     */
    private int normalise(final int input) {
        int res = input;
        while (res < 0) {
            res += bufferSize;
        }
        return res % bufferSize;
    }
    
    /**
     * Adds all items in the string array to the buffer.
     *
     * @param lines lines to add to the buffer
     */
    public void addToBuffer(final String[] lines) {
        for (String line : lines) {
            addToBuffer(line);
        }
    }
    
    
    /**
     * Adds the specified string to the buffer.
     * @param line The line to be added to the buffer
     */
    public void addToBuffer(final String line) {
        buffer[bufferMaximum] = line;
        bufferMaximum = normalise(bufferMaximum + 1);
        bufferPosition = bufferMaximum;
        
        if (buffer[bufferSize - 1] != null) {
            bufferMinimum = normalise(bufferMaximum + 1);
            buffer[bufferMaximum] = null;
        }
        
        target.setText("");
    }
    
    /**
     * Displays a colour picker for the target.
     *
     * @param irc show irc colours in the colour picker
     * @param hex show hex colours in the colour picker
     */
    private void showColourPicker(final boolean irc, final boolean hex) {
        if (Config.getOptionBool("general", "showcolourdialog")) {
            colourPicker = new ColourPickerDialog(irc, hex);
            colourPicker.addActionListener(new ActionListener() {
                public void actionPerformed(final ActionEvent actionEvent) {
                    target.setText(target.getText() + actionEvent.getActionCommand());
                    colourPicker.dispose();
                    colourPicker = null;
                }});
                colourPicker.setLocation((int) target.getLocationOnScreen().getX(), (int) target.getLocationOnScreen().getY() - colourPicker.getHeight());
                colourPicker.setVisible(true);
        }
    }
}
